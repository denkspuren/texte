<meta charset="utf-8" lang="de">
<script>window.markdeepOptions = { "tocStyle" : "auto" }</script>

    **OOP-Notizen, WS 2019/20**
    Dominikus Herzberg

# Vorbemerkung

!!! WARNING
    Wenn Sie bis morgen, Mittwoch (9.10.), keinen Zuhörerstatus gewählt haben, werden Sie aus dem Moodle-Kurs gelöscht. Nach dieser Deadline wird auch niemand mehr als Ersthörer zugelassen, d.h. Sie können keine Klausurzulassung mehr erwerben, wenn sie Ihnen fehlt.

Verzeihen Sie diese Unerbittlichkeit. Ohne klare Regeln und Deadlines ist eine Veranstaltung dieser Größe mit begrenzter Ausstattung an Tutoren und Zeit nicht zu bewältigen.

# VW0

Was in der JShell passierte:

~~~ text
System.out.println("Hello World!")
for(int i = 0; i <= 10; i++)



;
for(int i = 0; i <= 10; i++) System.out.println(i);
class A {}
new A()
/exit
~~~

# VW1

In dieser Woche haben Sie schon unglaublich viel gelernt. Sie haben gute Chancen, Kap. 3.1 (Variablen), Kap. 3.2 (Elementare Datentypen) und Kap. 3.3 (Literale) im Kofler-Buch zu verstehen. Und auch Kap. 3.4 (Variablen im größeren Java-Kontext) sollte Ihnen zugänglich sein.

Und weil wir uns dem Klassen als Kompositionsmechanismus für Typen genähert haben, können Sie auch mal einen Blick in Kap. 11 (Top-Level Klassen) werfen, um mit den Begrifflichkeiten in Kontakt zu kommen. Wenn Ihnen das zu schwer wird, an Kap. 2 (Java-Crashkurs) sollten Sie sich unbedingt versuchen.

Werfen Sie auch schon Blicke in Kap. 4 (Operatoren) und Kap. 5 (Verzweigungen und Schleifen)!

## Dienstag

In Moodle sind aktuell 264 Teilnehmer eingetragen, 243 haben einen Zuhörerstatus gewählt: 224 Ersthörer, 12 Wiederholer, 7 Zaungäste (Stand 8.10., 13:30). 

!!!
    Die Veranstaltung am Mittwoch (9.10.) im 4. Block muss leider ein wenig kürzer ausfallen von 14-15:00 Uhr, da ich im Fachbereichsrat zu einem Berufungsverfahren Stellung nehmen muss.

* Wie oft muss ich ins Praktikum gehen?
* Was ist die Definition von "Ersthörer"?
* Was ist ein Computer?
* Was ist ein Bit?

-----

<details>
    <summary>Wollen Sie sehen, was heute in der JShell geschah?</summary>
~~~ text
7
7;
$2
int i = 7;
int i = 7.0
int i = (int)7.4
i
int i = (int)7.446464763
int i = (int)7.9999
$2
true
20s
(short)20
20L
(byte)20
char c = 'A'
'A' + 1
(char)65
2
~~~
</details>

## Mittwoch

**Einzelzeichen**: Warum ergibt `'A' + 1` eine `66` und nicht das Folgezeichen `'B'`?

**Float**: Das Schlüsselwort `float` steht in Java für den Zahlentyp einer Fließkommazahl aus 4 Bytes. Das Wort "float" ist im Englischen eine Kurzform für was?

**Let it flow**: Beschreiben Sie, was bei der Anweisung `float f = 1.024` vor sich geht!

**Typ**: Was ist ein Typ?

<details>
    <summary>Lösung: Einzelzeichen</summary>
Der Additionsoperator `+` addiert ein Datum vom Typ `char` und ein Datum vom Typ `int`. Sie erkennen das an den Literalen: `'A'` ist das Einzelzeichen "A" vom Typ `char`, `1` eine Ganzzahl vom Typ `int`. Zur Erinnerung: Der Typ `char` gehört zu den Zahlentypen, genauer zu den Ganzzahltypen.

Zwei verschiedene Zahlentypen können nicht einfach so addiert werden, dafür gibt es Anpassungsregeln. In diesem Fall wird der Wert vom Typ `char` auf einen Wert vom Typ `int` "geliftet" -- es handelt sich um eine sogenannte _widening conversion_, die den Typ anpasst, dabei aber den Wert erhält. Schlußendlich wird bei `'A' + 1` also faktisch ein `65 + 1` gerechnet. Die Addition zweier Zahlen vom Typ `int` ist wieder ein `int`. Und ein Wert vom Typ `int` wird als Dezimalzahl angezeigt.

Wenn Sie die JShell mit dem Argument `-v` starten (`-v` steht für _verbose_, also für ausführlichere Interaktionsmeldungen), bekommen Sie Typinformationen angezeigt, was ein wenig hilft, diese Typumwandlung zu erahnen:

~~~ text
> jshell -v
|  Welcome to JShell -- Version 12.0.2
|  For an introduction type: /help intro

jshell> 'A' + 1
$1 ==> 66
|  created scratch variable $1 : int
~~~
</details>

<details>
    <summary>Lösung: "float"</summary>
Im deutschen Sprachraum schreiben wir Kommazahlen auch mit einem Komma, z.B. 1,024. Da die Anzahl der Nachkommastellen das Komma sozusagen variabel in seiner Position erscheinen lässt, spricht man von Gleitkomma- bzw. Fließkommazahlen. Im englischen Sprachraum heißt es _floating point number_, kurz _float_, was verrät, dass Kommazahlen mit einem Punkt notiert werden, z.B. 1.024. Java ist der englischsprachigen Schreibweise verpflichtet. 
</details>

<details>
    <summary>Lösung: Let it flow</summary>
Sie erhalten eine Fehlermeldung. Warum? `1.024` ist das Literal für die Fließkommazahl vom Typ `double` 1,024. (In der Schule haben Sie gelernt, Kommazahlen mit einem Komma und nicht mit einem Punkt zu schreiben. Im Amerikanischen werden Kommazahlen mit einem Punkt geschrieben. Sie erkennen daran, dass ). Der Zahlenwert mit 8 Bytes kann nicht einfach so in einer Variable vom Typ `float` (Fließkommazahl mit 4 Bytes) gespeichert werden. Java nimmt keine automatische Herabstufung des Typen vor (_narrowing conversion_), daher kommt es zu einer Fehlermeldung.

~~~
jshell> float f = 1.204
|  Error:
|  incompatible types: possible lossy conversion from double to float
|  float f = 1.204;
|            ^---^
~~~
</details>

<details>
    <summary>Lösung: Typ</summary>
Formal gesprochen ist ein Typ eine Menge von Datenwerten. Das Konzept des Typs ist eng verwandt mit dem Konzept der Menge aus der Mengenlehre.

Jeder Datenwert hat einen Typ. Anders ausgedrückt: Jeder Datenwert ist einem Typ zugeordnet. Der Typ legt fest, wie der Datenwert zu interpretieren ist (z.B. als Ganzzahl), wie die Speicherorganisation aussieht (das umfasst die Anzahl der benötigten Speicherzellen in Bytes und die Kodierung) und wie der Datenwert dargestellt wird.

Für primitive Typen ist die Kenntnis der Anzahl der benötigten Bytes im Speicher und die verwendete Kodierung essenziell, um die Besonderheiten des Umgangs, vor allem des Rechnens, mit primitiven Datenwerten zu verstehen. Ein grobes Verständnis der Speicherorganisation von Arrays hilft, die Effiziens der Datenhaltung nachzuvollziehen. Für sonstige, nicht-primitive Typen (Klassen und Interfaces) organisiert Java die Datenwerte (Instanzen genannt) zwar eigenständig im Speicher, doch leitet sich die Speicherorganisation unmittelbar aus den Feldern einer Klasse ab. Sie müssen auch hier ein Verständnis entwickeln, um Datenstrukturen intellektuell zu erfassen. Wovon Java Sie konsequent befreit, ist ein Wissen darum, wo genau im Speicher Datenwerte liegen und wie es den Speicher verwaltet. 
</details>

<details>
<summary>Sehen, was zuletzt in der JShell geschah!</summary>
~~~ text
'A' + 1
float f = 1.204
byte a = 1
'A' + a
byte b = 1
byte b = 1000
byte b = 127
byte b = 128
int i = 1
byte b = i
byte b = (byte)i
byte a = 1
'A' + a
float f = 1.024
float f = 1.024f
float f = (float)1.024
class Person {
int personalnr;
float jahresgehalt;
}
Person p = new Person()
p.personalnr = 1
p.jahresgehalt = 20.000f
p.jahresgehalt
p.jahresgehalt = 20_000f
p.jahresgehalt
/ex
~~~
</details>

# VW2

!!! WARNING
    Sind Sie chronisch krank, leiden Sie unter Einschränkungen, die Ihnen das Studium erschweren oder besonderer Berücksichtigung bedürfen? Falls ja, wenden Sie sich unbedingt und am besten gleich beim BliZ (https://www.thm.de/bliz/). Hier sind Sie mit Ihrem Anliegen gut aufgehoben. Sie werden merken: Wir alle versuchen, Ihnen das Studium so gut wie möglich studierbar zu machen. 

## Dienstag

**Typfrage**: Erläutern Sie, was Sie zu dem Typ `long` alles wissen!

**Literal**: Was ist ein Literal? Geben Sie drei grundlegend unterschiedliche Beispiele für Literale an.

**Punkt**: Sie benötigen eine Datenstruktur, mit der Sie die Idee eines Punktes in einer Fläche abbilden können anhand seiner kartesischen Koordination _x_ und _y_. Erstellen Sie den Datentypen dazu. Legen Sie zwei Punkte namens `ursprung` und `xEins` an und belegen Sie `ursprung` mit den Werten (0,0) und `xEins` mit den Werten (1,0). 

<details>
    <summary>Lösung: Typfrage `long`</summary>
Der Typ `long` ist ein primitiver Datentyp für Ganzzahlen ("primitiv" meint: ein einfacher, grundlegender Datentyp), der eine Ganzzahl im Zweierkomplement mit 8 Bytes kodiert. 
</details>

<details>
    <summary>Lösung: Literal</summary>
Ein Literal ist eine Schreibweise für Datenwerte. Die Schreibweise ist eindeutig und lässt den Typ des Datenwerts erkennen. Beispiele sind `'Z'` für einen `char`-Wert, `0.007` für einen `double`-Wert und `0b100` für den `int`-Wert 4 in binärer Schreibweise.
</details>

<details>
    <summary>Lösung: Punkt</summary>
Die Wahl des Typs für `x` und `y` ist an dieser Stelle nicht so entscheidend. Manchmal geben Ihnen Aufgaben Freiheitsgrade, die begründete Entscheidungen von Ihnen verlangen. Gut begründbare Typen sind `float` und `long` (das passt zu Ihrer Schulerfahrung) oder `int` für Punkte in einer diskretisierten Fläche. 
~~~ java 
class Punkt {
    float x;
    float y;
}
~~~
</details>

<details>
<summary>Ja, will ich sehen, was heute in der JShell geschah!</summary>
~~~ text
jshell> /history

class A {}
A a
int i
int i = 3
i
class Point {
float x;
float y;
}
Point p
p = new Point()
p.x = 3.5f
p.y = 0
p.x
Math.sqrt(9)
Math.pow(3.0,2)
p
Math.sqrt(Math.pow(p.x,2) + Math.pow(p.y,2))
~~~
</details>


## Mittwoch

**Zweimal `long`**: Deklarieren Sie zwei Variablen namens `a` und `b` mit zwei Zahlenwerten vom Typ `long` und initialisieren Sie die Variablen. Denken Sie sich beispielhafte Werte aus.

<details>
    <summary>Lösung</summary>
Folgende Begrifflichkeiten sind auseinander zu halten: deklarieren, initialisieren und zuweisen. Mit einer Deklaration legen Sie etwas an. Im Fall der Variablen-Deklaration legen Sie eine Variable an. Das erfordert die Angabe des Namens und des Typs der Variablen.

~~~ java
long a; // Variablen-Deklaration ohne Initialisierung
~~~

Wenn Sie der Variablen bei der Deklaration einen Wert zuweisen, dann weisen Sie der Variablen ihren initialen Wert zu (ihren "Anfangswert"); das nennt man _initialisieren_.

~~~ java
long a = 12L; // Variablen-Deklaration mit Initialisierung
~~~

Die Zuweisung kann auch nach der Deklaration erfolgen. Dann handelt es sich nicht um eine Initialisierung. Warum? Bei einer Deklaration ohne ausdrücklichen Initialwert wird ein Default-Wert (ein Standardwert) gesetzt. Bei Zahlen ist das die Null.

~~~ java
long a; // Variablen-Deklaration; a bekommt den Initialwert 0
a = 12L; // Variable a bekommt den Wert 12 zugewiesen
~~~

Es gibt Fälle, wo eine Variable bei der Deklaration initialisiert werden muss.
</details>

**Geht das?**: Sie haben soeben `a` und `b` deklariert. Jemand tippert auf der JShell etwas ein, drückt aber noch nicht die Eingabetaste (ENTER). Was passiert, wenn Sie ENTER drücken?

~~~ text
jshell> a = b = b = a
~~~

**Farbpunkt**: Gehen Sie davon aus, dass es die Klasse `Point` von gestern bereits gibt. Legen Sie einen Datentypen an, der einen Farbpunkt (`ColorPoint`) repräsentieren soll, der sich aus einem Punkt (`Point`) und einer Zahl für den Farbwert zusammensetzt. Zeigen Sie beispielhaft, wie Sie eine Variable namens `cp` anlegen, die einen solchen Datenwert speichert; denken Sie sich Beispielwerte aus.

**Vorbereitung**: Als Delegierte:r sollen Sie vorbereitet beim Delegiertentreffen erscheinen. Was heißt es, _vorbereitet_ zu sein?

<details>
    <summary>Wollen Sie wissen, was heute in der JShell geschah?</summary>
~~~ text
jshell> /history

long a = 12
4_000
long a = 4_000_000_000
long a = 4_000_000_000L
Integer.MAX_VALUE
Integer.MIN_VALUE
int i = Integer.MAX_VALUE
int i = 2147483648
long a, b;
long a = 3L, b;
long a = 3L, b = 12L;
long a = 3L,b = 12L;
long a = 3L,
b = 12L;
a = 2 * b = a + a
a
b
b = -12L
a = 2 * b = a + a
a = 2 * (b = a + a)
class Point { float x, y; }
Point p = new Point();
p.x = 3.0f
new Point()
$24.x
ColorPoint cp = new ColorPoint()
class ColorPoint { Point p; int color; }
ColorPoint cp = new ColorPoint()
cp
ColorPoint cp
ColorPoint cp = new ColorPoint()
cp.p
cp.p = new Point()
cp
cp.p
cp.p.x = 1f
cp.p.y = 2f
cp.color
cp.color = 100
cp
p
Point p1 = new Point()
p1.x
p1.y
p.x
p.y
p
p1
p = p1
p
p1
p.x = 1234f
p1.x
~~~
Was wichtig ist zu unterscheiden: Die Variable `p` und die Variable `cp.p` sind verschieden. Die Variablen `p` und `cp` "leben" im Kontext der JShell. Die Variable `p` zugeriffen über `cp` (also `cp.p`) "lebt" in dem Kontext von `cp`.
</details>

# VW3

## Dienstag

**Zweimal A**: Was ist eine Anweisung, was ein Ausdruck, was ein Anweisungsausdruck?

**String**: Was ist ein `String` in Java? Wie sieht ein `String`-Literal aus?

**Firma**: Legen Sie eine Klasse namens `Person` an; eine Person hat ein Alter (`age`) und einen Namen (`name`). Legen Sie eine Klasse namens `Firm` an, die einen Namen `name` hat und ein Array vom Typ `Person`, das die Angestellten (`employees`) repräsentiert. Legen Sie Instanzen mit Beispielwerten an.

**Abstand**: (a) Geben Sie den Ausdruck an, der von einem Punkt (Klasse `Point` von VW2) den Abstand vom Ursprung des Koordinatensystems berechnet. (b) Packen Sie die Berechnung des Abstands in eine Methode.

<details>
    <summary>Lösung: Abstand</summary>
Gegeben sei die Klasse `Point` aus VW2.

~~~ java
class Point {
    double x, y;
}
~~~

Der Abstand zum Ursprung berechnet sich für eine Instanz `p` wie folgt:

~~~ text
jshell> Point p = new Point()
p ==> Point@7f13d6e

jshell> p.x = 2.7
$12 ==> 2.7

jshell> p.y = -0.4
$13 ==> -0.4

jshell> Math.sqrt(Math.pow(p.x, 2) + Math.pow(p.y,2))
$14 ==> 2.7294688127912363
~~~

Es gibt mehrere Möglichkeiten, eine Methode anzulegen:

**1. Variante: stand-alone Methode (geht nur in JShell)**

~~~ java
double distance(Point p) {
    return Math.sqrt(Math.pow(p.x, 2) + Math.pow(p.y,2));
}
~~~

~~~ text
jshell> distance(p)
$16 ==> 2.7294688127912363
~~~

Solche alleinstehenden Methoden müssen, wenn man nicht in der JShell ist, als Klassenmethoden realisiert werden. Methoden brauchen immer eine Klasse als Heimat, dort als Klassen- oder als Instanzmethoden. Klassenmethoden erkennt man daran, dass ihnen das Schlüsselwort `static` vorangestellt ist. Das geht dann so:

~~~ java
class PointTool {
    static double distance(Point p) {
        return Math.sqrt(Math.pow(p.x, 2) + Math.pow(p.y,2));
    }
}
~~~

~~~ text 
jshell> PointTool.distance(p)
$29 ==> 2.7294688127912363
~~~

**2. Variante: Instanzmethode**

~~~ java
class Point {
    double x, y;

    double distance() {
        return Math.sqrt(Math.pow(x, 2) + Math.pow(y,2));
    }
}
~~~

~~~ text
jshell> Point p = new Point()
p ==> Point@1f7030a6

jshell> p.x = 2.7
$19 ==> 2.7

jshell> p.y = -0.4
$20 ==> -0.4

jshell> p.distance()
$21 ==> 2.7294688127912363
~~~

Was Sie auf gar keinen Fall machen dürfen:

**Teufelchen 1: Werte per `print` ausgeben!**

~~~ java
class Point {
    double x, y;

    void distance() {
        System.out.println(Math.sqrt(Math.pow(x, 2) + Math.pow(y,2)));
    }
}
~~~

~~~ text 
jshell> Point p = new Point()
p ==> Point@53f65459

jshell> p.x = 2.7
$24 ==> 2.7

jshell> p.y = -0.4
$25 ==> -0.4

jshell> p.distance() // Hier passiert nicht das, was Sie zu sehen glauben!
2.7294688127912363
~~~

Schauen Sie mal genau hin, was hier anders ist. Und dann versuchen Sie sich das zu erklären!

!!! WARNING
    In unserem Kurs gibt es eine ganz einfache Regel: Du sollst keine `print(ln)`-Anweisung benutzen! Das dürfen Sie nur dann, wenn die Aufgabenstellung Sie dazu auffordert.

**Teufelchen 2: Objektorientierung aushebeln**

~~~ java
class Point {
    double x, y;

    double distance(Point p) {
        return Math.sqrt(Math.pow(p.x, 2) + Math.pow(p.y,2));
    }
}
~~~

Ist Ihnen was aufgefallen? In dieser Aufgabe geht es im Kern um die Kontexte von Methoden (Klassen- oder Instanzmethode) und die Kontexte von Variablen (Klassen- oder Instanzvariablen; hier haben wir nur Instanzvariablen genutzt). Instanzmethoden können auf die Instanzvariablen unmittelbar zugreifen. Und Methoden deklarieren ebenfalls Variablen für den Rumpf der Methode.
</details>

## Mittwoch

**Anweisung/Ausdruck**: Was ist eine Anweisung? Was ist ein Ausdruck? (Bitte geben Sie auch die englischen Begriffe dafür an.)

**Variable**: Was ist eine Instanz-, was eine Klassenvariable?

**Linie**: Die Klassen `Point` (Punkt) und `Line` (Linie) sind gegeben. Eine Linie `line` habe den Startpunkt $(1,1)$ und den Endpunkt $(-3,2)$. (1) Schreiben Sie die notwendige Folge von Anweisungen auf, um `line` mit den angegebenen Werten aufzusetzen. (2) Zeichnen Sie das Objektbild zur entstandenen Situation.

~~~ java
class Point {
    double x, y;
}

class Line {
    Point start;
    Point end;
}
~~~

**Kofler, S.215f.**: In dem folgenden Text aus dem Kofler-Buch steckt ein Fehler: Finden und erklären Sie ihn!

> Normalerweise gelten in einer Klasse deklarierte Variablen für eine konkrete
> Instanz einer Klasse – daher rührt auch der Begriff _Instanzvariable_.
> Die in den Variablen bzw. Datenfeldern gespeicherten Daten gehören
> also zum jeweiligen Objekt und sind vollkommen unabhängig von anderen
> Objekten derselben Klasse. Auch in der Klasse definierte Methoden
> können nur verwendet werden, nachdem zuerst eine Instanz der Klasse
> erzeugt wurde.
>
>   Genau das trifft auf die vorhin vorgestellte Rechteck-Klasse zu: Sie können
> mehrere Rechteck-Objekte erzeugen. Deren Daten werden vollkommen
> unabhängig voneinander gespeichert. Die Methoden `berechneUmfang`
> und `berechneFlaeche` können nur verwendet werden, _nachdem_ ein Rechteck-
> Objekt erzeugt wurde. In der Fachsprache nennt man alle Klassenvariablen
> und Methoden von `Rechteck` _nichtstatisch_. -- Kofler (2019, S. 215 f.)

Anbei (aber nicht wesentlich für die Aufgabe), der Code zur Klasse `Rechteck` (Kofler, 2019, S. 211 f.):

~~~ java 
// Projekt kap11 -rechteck -intro , Datei Rechteck.java
public class Rechteck {
    // Instanzvariablen
    public double laenge , breite;
    // Methoden
    public double berechneUmfang() {
        return (laenge+breite)*2;
    }
    public double berechneFlaeche() {
        return laenge*breite;
    }
}
~~~

# VW4

!!! WARNING
    Am 11./12. November, bin ich auf einer Tagung an der Hochschule Coburg. Deshalb entfällt der Dienstagstermin in VW6 (12.11.).

## Dienstag

**Zuweisung**: Was müssen Sie an der folgenden Zeile warum ändern, damit Sie lauffähig wird? Rechts vom Zuweisungsoperator dürfen Sie nichts löschen.

~~~ java 
int a = 3 + b = 4 + a;
~~~

**Gerade**: Schreiben Sie eine Methode namens `countEven`, die ein Array aus Ganzzahlen entgegennimmt und die Anzahl der geraden Zahlen in dem Array zurückgibt.

<details>
    <summary>Lösung: Zuweisung</summary>

1. Die Variable `a` kann rechts vom Zuweisungsoperator nur verwendet werden, wenn `a` zuvor deklariert wurde; gleiches gilt für `b`. Da mehrfache Deklarationen ein und derselben Variable in Java nicht erlaubt sind (die JShell ist aus Gründen des interaktiven "Spielens" großzügiger), muss es lauten:

~~~ java
a = 3 + b = 4 + a;
~~~

2. Der Additionsoperator bindet höher als der Zuweisungsoperator. Die Ergebnisse der Additionen (seien sie beispielsweise `7` für `3 + b` und `-10` für `4 + a`) würden dann mit den Beispielwerten den Zuweisungsausdruck `a = 7 = -10` ergeben. Da die Zuweisung rechtsassoziativ ist, kann die Zuweisung `7 = -10` nicht ausgeführt werden, da links vom Zuweisungsoperator eine Variable stehen muss. Das erklärt auch die Fehlermeldung:

~~~ text 
jshell> a = 3 + b = 4 + a
|  Error:
|  unexpected type
|    required: variable
|    found:    value
|  a = 3 + b = 4 + a
|      ^---^
~~~
</details>

## Mittwoch

**Assoziativität**: Ist der Operator "`+`" rechts- oder linksassoziativ? Geben Sie ein Beispiel an, mit dem Sie Ihre Behauptung überprüfen können.

**Gerade?**: Schreiben Sie eine Methode `isEven`, die folgendes Verfahren umsetzt: Wenn die übergebene Zahl gleich `1` ist, dann beantwortet die Methode die Frage mit `false`, wenn die Zahl gleich `0` ist, dann lautet die Antwort `true`. Ansonsten wird der an `isEven` übergebene Zahlenwert um den Wert `2` vermindert und die Frage `isEven` wird erneut gestellt.

Gehen Sie davon aus, dass die an `isEven` übergebene Zahl immer positiv ist.

**Abstand**: (a) Geben Sie den Ausdruck an, der von einem Punkt (Klasse `Point` von VW2) den Abstand vom Ursprung des Koordinatensystems berechnet. (b) Packen Sie die Berechnung des Abstands in eine Methode. (Wiederholung zur Aufarbeitung, siehe VW3)

<details>
<summary>Lösung: Assoziativität</summary>
Die Frage ist, ob `a + b + c` ein Ergebnis liefert, das entweder identisch ist mit `(a + b) + c` (linkassoziativ) oder mit `a + (b + c)` (rechtsassoziativ). Wird also zuerst der linke Plus-Operator berechnet oder der rechte?

Um das zu überprüfen, brauchen wir einen Trick, der bei gleichen Zahlen dennoch unterschiedliche Ergebnisse generiert, je nachdem, welches Plus man zuerst anwendet. Ich habe dafür ein wenig experimentieren müssen.

~~~ text 
jshell> float a = 0.7f, b = 0.9f, c = 0.3f;
a ==> 0.7
b ==> 0.9
c ==> 0.3

jshell> (a + b) + c
$32 ==> 1.8999999

jshell> a + (b + c)
$33 ==> 1.9000001

jshell> a + b + c // `+` ist linksassoziativ
$34 ==> 1.8999999
~~~

Können Sie auch ein Beispiel für Ganzzahlen konstruieren?

<details>
<summary>Haben Sie es herausgefunden?</summary>
Es ist eine Besonderheit bei Java, dass die verwendete Modulo-Arithmetik bei Ganzzahlen neutral gegenüber der Reihenfolge bei der Addition ist. Bei Fließkommazahlen spielt es eine entscheidende Rolle, welche Zahlen zuerst berechnet werden, weil die Ungenauigkeiten in den Nachkommastellen unterschiedlich ausfallen können -- so zeigt es auch das Beispiel.
</details>
</details>

<details>
    <summary>Lösung: Gerade?</summary>
Die Aufgabe wird praktisch wörtlich durch die rekursive Lösung erfüllt.

!!! 
    Normalerweise verbiete ich Ihnen den Gebrauch von `print`-Anweisungen. Wobei ein eingestreutes `println` jedoch sehr helfen kann, ist, einen Einblick in die Abarbeitung des Codes zu gewinnen.

Eine Methode heißt _rekursiv_, wenn sie in ihrem Rumpf mit einem Aufruf auf sich selbst Bezug nimmt. Aber seien Sie wachsam: Jeder Aufruf einer Methode, egal ob ein Fremd- oder Selbstaufruf, wird von einer neuen Abarbeitungseinheit bearbeitet, die einen frischen Satz an Variablen anlegt. Beim Selbstaufruf wird lediglich Bezug auf den gleichen Code genommen. Grundsätzlich unterscheidet sich das Vorgehen und der Aufbau einer Aufrufkette (Stichwort _callstack_) nicht von dem bei Fremdaufrufen.

~~~ java 
boolean isEven(int n) {
    // System.out.println("n = " + n);
    if (n == 1) return false;
    if (n == 0) return true;
    return isEven(n - 2);
}
~~~

Die nachfolgende Variante ist _iterativ_, weil sie sich zur Lösung eines Wiederholungskonstrukts bedient. Vom Code her ist der Unterschied in der inneren Abarbeitung minimal.

~~~ java 
boolean isEven(int n) {
    while (true) {
        if (n == 0) return true;
        if (n == 1) return false;
        n -= 2;
    }
}
~~~

Mit der `while`-Schleife kann man sich auch andere Varianten erdenken:

~~~ java
boolean isEven(int n) {
    while (n > 1) n -= 2;
    return n == 0;
}
~~~

Oder, fast noch besser, so dass niemand mehr darüber nachdenken muss, ob die Bedingung `(n > 1)` wirklich das ausschließt, was sie ausschließen soll:

~~~ java 
boolean isEven(int n) {
    while (n != 0 && n != 1) n -= 2;
    return n == 0;
}
~~~

Überlegen Sie sich selbst mögliche Umsetzungen mit der `for`-Schleife! (Die hier, nebenbei gesagt, nicht das beste Mittel der Wahl ist. Jede Schleifenart hat ihre eigenen kleinen Vorzüge und kleinen Nachteile.)
</details>

# VW5

## Dienstag

**Zuweisung**: Sie sehen in einem Java-Programm folgende Codezeile. Begründen Sie, was Sie davon halten!

~~~ java
int i = j % 1;
~~~

**`doit`**: Sie sehen die folgende Implementierung einer Methode namens `doit`. Was macht die Methode und was wäre folglich ein besserer Name für sie?

~~~ java
boolean doit(int n) { return (n & 1) > 0; }
~~~

**Zahl**: Erstellen Sie eine Klasse namens `Zahl`. Eine Instanz von Zahl steht für eine Ganzzahl und kann mit einem `int`-Wert initialisiert werden. Implementieren Sie neben dem Konstruktor eine Methode `addiere`, um zwei Zahlen addieren zu können; das Ergebnis soll eine neue Zahl sein. Ergänzen Sie ein Methode `negiere`, um eine neue Zahl mit dem negierten Zahlenwert zu generieren. Implementieren Sie die `toString`-Methode, um Zahlen in der Form `Zahl(3)` oder `Zahl(-17)` darzustellen. 

<details>
    <summary>Lösung: doit</summary>
Die Implementierung zielt auf die interne Kodierung von Ganzzahlen im Zweierkomplement ab. Eine ungerade Zahl hat an der Bitstelle ganz rechts (dem _Least Significant Bit_, LSB) immer eine `1` stehen, bei einer geraden Zahl immer eine `0`. Der `&`-Operator "filtert" über das binäre Und das LSB einer beliebigen Ganzzahl heraus. Ist es `1` (also größer Null), dann liegt eine ungerade Zahl vor, das Ergebnis ist `true`. Ansonsten zeigt ein `false` eine gerade Zahl an. Die Methode hieße also besser `isOdd` (im Sinne von "Bist Du ungerade?").

In der Regel trennt man in der Programmiertechnik strikt die Repräsentation eines Datums von seiner Kodierung. Oder anders ausgedrückt: Es sollte einer Nutzerin bzw. eines Nutzers von Ganzzahlen vollkommen egal sein, wie die Zahlen intern kodiert werden. Der `&`-Operator eröffnet einem jedoch einen Zugang zu der Kodierung einer Ganzzahl in Bits -- das ist eigentlich überflüssig. Möchte man die Trennung aufrecht erhalten, dann ist es angebracht, den Modulo-Operator zu verwenden. Die Modulo-Operation ist für Ganzzahlen definiert, eine Kenntnis der Kodierung ist dafür nicht notwendig.

~~~
boolean isOdd(int n) { return n % 2 != 0; }
~~~

<details>
    <summary>Warum habe ich nicht `return n % 2 == 1` geschrieben?</summary>
Weil z.B. `-17 % 2` den Wert `-1` ergibt und nicht `1`. Die Ergebnisse für Modulo 2 können also `-1`, `0` und `+1` sein. Und wir wollen nur wissen, ob es sich entweder um eine `0` (gerade) oder um eine `-1` bzw. `+1` (ungerade) handelt. 
</details>

Man kann an diesem kleinen Programm einen weiteren interessanten Aspekt der Programmierung diskutieren. Wir haben aus der Aufgabe der letzten Woche gesehen, dass man über die wiederholte Subtraktion von `-2` feststellen kann, ob eine Zahl gerade bzw. ungerade ist. Das ist nichts anderes als die Simulation der Division bezüglich des Restwertes als Prozess, d.h. als sehr kleinschrittigen Vorgang. Man sucht bei der Programmierung immer wieder nach Alternativen, die solche Prozesse abkürzen. In diesen Sinne kann es für die Realisierung spezieller Modulo-Werte (wie bei Modulo 2) sehr effizient sein, auf die Kodierung einer Ganzzahl per `&`-Operator zuzugreifen, wenn die Kodierung selber nicht erst errechnet werden muss. So sieht sich bisweilen die absichtsvolle Ausblendung von Kodierungungsdetails, die keine Rolle spielen sollten, einem Bedarf nach effizienter Umsetzung von Rechenprozessen gegenüber, wo Kodierungswissen ausgenutzt wird.

In diesem speziellen Fall sollten Sie nicht ohne sehr trifftige Gründe bei der Verwendung des Modulo-Operators bleiben. Die `%`-Operation kostet die Hardware genauso viel Zeit, wie die `&`-Operation.
</details>

<details>
    <summary>Lösung: Zahl</summary>
Diese Aufgabe möchte eine bestimmte Lösung von Ihnen sehen. Hier zeige ich Ihnen auf, welche grundsätzlichen Sichtweisen verschiedene Arten der Implementierung z.B. der Addition mit sich bringen. Ich habe in der Veranstaltung von verschiedenen "Erzählungen" gesprochen, die Sie in den Code einschreiben können.

* Klassenerzählung
* Instanzerzählung
    - Die Unveränderlichkeitserzählung ("Ich bin unveränderlich!")
    - Die Veränderlichkeitserzählung ("Ich habe einen veränderlichen Zustand.")
        - Ich bin nicht mein eigener Rückgabewert (Methode ist z.B. `void`)
        - Ich bin mein eigener Rückgabewert (`return this;`)

!!! 
    Der Fachbegriff für "unveränderlich" lautet _immutabel_, der für "veränderlich" _mutabel_.
    
Im Kern geht es darum, ob man ein Objekt als _mutabel_ (veränderlich) oder _immutabel_ (unveränderlich) auslegt und ob man den Umgang mit den Objekten als Klassen- oder Instanzmethoden implementiert. 

### Die Veränderlichkeitserzählung (1. Variante)

Traditionell versteht sich die Objektorientierung als Veränderlichkeitserzählung: Objekte können die Werte ihrer Instanzvariablen ändern. Man sagt, ein Objekt hat einen Zustand. Unter dem Zustand sind -- formal gesprochen -- all die Werte derjenigen Instanzvariablen gemeint, die nicht ableitbar sind (heißt: nicht berechenbar aus anderen Werten) und die sich über die Zeit ändern können. Die traditionelle Veränderlichkeitserzählung deklariert die Methoden, die den Zustand eines Objekts ändern, typischerweise als `void`. Eine Methode, die `void` als Rückgabetyp hat, muss einen (Seiten)Effekt haben. Ein häufiger Effekt ist die Änderung des Zustands eines Objekts.

~~~ java 
class Zahl {
    int value;
    Zahl(int value) {
        this.value = value;
    }
    void addiere(Zahl z) {
        this.value = value + z.value;
    }
    void negiere() {
        value = -value;
    }
    public String toString() {
        return "Zahl(" + value + ")";
    }
}
~~~

Diese Erzählart führt zu einem anweisungsorientiertem Programmierstil. Sie müssen mehrere Additionen als Abfolge von Anweisungen formulieren. Die Anweisungen sind ohne Rückgabewert, dennoch ändert sich der `value`-Wert der über die Variable `z` referenzierten Instanz von `Zahl`.

~~~ text 
jshell> Zahl z = new Zahl(13)
z ==> Zahl(13)

jshell> z.addiere(new Zahl(5))

jshell> z.negiere()

jshell> z.addiere(new Zahl(-2))

jshell> z
z ==> Zahl(-20)
~~~

### Die Unveränderlichkeitserzählung

Mittlerweile ist die Unveränderlichkeitserzählung sehr modern geworden, da sie softwaretechnisch einige Vorteile mit sich bringt. Um anzuzeigen, dass eine Variable nur einmal eine Wertzuweisung erhalten kann, deklariert man sie als `final`. Da eine Instanz von `Zahl` den Wert `value` gar nicht mehr ändern kann, bleibt einem gar nichts anderes mehr übrig als eine neue Instanz von `Zahl` mit einem neuen Zahlenwert zu erzeugen.

~~~ java 
class Zahl {
    final int value;

    Zahl(int value) {
        this.value = value;
    }
    Zahl addiere(Zahl z) {
        return new Zahl(value + z.value);
    }
    Zahl negiere() {
        return new Zahl(-value);
    }
    public String toString() {
        return "Zahl(" + value + ")";
    }
}
~~~

Der sich daraus ergebende Programmierstil ist ausdrucksorientiert. Man kann die Methodenaufrufe hintereinander ketten.

~~~ text 
jshell> Zahl z = new Zahl(13)
z ==> Zahl(13)

jshell> z.addiere(new Zahl(5)).negiere().addiere(new Zahl(-2))
$55 ==> Zahl(-20)

jshell> z
z ==> Zahl(13)
~~~

### Die Veränderlichkeitserzählung (2. Variante)

Die Eleganz der Verkettung von Methodenaufrufen kann man auch bei der Programmierung mit mutablen Objekten nutzen.

~~~ java 
class Zahl {
    int value;
    Zahl(int value) {
        this.value = value;
    }
    Zahl addiere(Zahl z) {
        this.value = value + z.value;
        return this;
    }
    Zahl negiere() {
        value = -value;
        return this;
    }
    public String toString() {
        return "Zahl(" + value + ")";
    }
}
~~~

Man muss genau hinschauen, um den Unterschied zur Umsetzung mit immutablen Objekten zu bemerken. Alles wirkt gleich, tatsächlich ändert sich der Zustand, d.h. der Zahlenwert von `z`.

~~~ text 
jshell> Zahl z = new Zahl(13)
z ==> Zahl(13)

jshell> z.addiere(new Zahl(5)).negiere().addiere(new Zahl(-2))
$60 ==> Zahl(-20)

jshell> z
z ==> Zahl(-20)
~~~

### Die Klassenerzählung

Man kann die Methoden `addiere` und `negiere` als Klassenmethoden auslegen, dann notwendigerweise mit zwei bzw. einem `Zahl`-Parameter. Es macht bei diesem Programmierstil nur begrenzt Sinn mutabel zu programmieren. Soll das Ergebnis bei der Addition den Wert von `z1` oder `z2` verändern? Egal, wie die Antwort ausfällt, wenn man eines der Objekte mutieren möchte, dann bietet sich ganz klar die Veränderlichkeitserzählung an -- die erzählt dann, was man tatsächlich vorhat, statt den Vorgang über die Klassenerzählung zu verschleiern. 

~~~ java
class Zahl {
    static Zahl addiere(Zahl z1, Zahl z2) {
        return new Zahl(z1.value + z2.value);
    }
    static Zahl negiere(Zahl z) {
        return new Zahl(-z.value);
    }    
    int value;
    Zahl(int value) {
        this.value = value;
    }
    public String toString() {
        return "Zahl(" + value + ")";
    }
}
~~~

Die Konsequenz dieses Ansatzes ist keine Verkettung, sondern eine Verschachtelung von Ausdrücken.

~~~ text 
jshell> Zahl.addiere(Zahl.negiere(Zahl.addiere(new Zahl(13), new Zahl(5))), new Zahl(-2))
$65 ==> Zahl(-20)
~~~

Bei der Implementierung von `addiere` als Klassenmethode bringt die Klasse zwei Objekte zusammen und berechnet das Ergebnis der Verknüpfung, hier der Addition. Bei der Implementierung als Instanzmethode ist eine Instanz bereits im Kontext der Methode und benötigt nur noch das andere Objekt, um die Verknüpfung zu realisieren.

!!! WARNING
    Gehen Sie als Anfänger:in in der Programmierung bitte sehr sparsam mit Klassenmethoden um. Noch deutlicher: Vermeiden Sie sie schlicht, da Sie objektorientiert, d.h. mit Instanzmethoden arbeiten sollen. Sonst trainieren Sie die Objektdenke nicht.
</details>

## Mittwoch

**Array**: Gegeben sei die folgende Folge von Anweisungen:

~~~ text 
int[] a = {1,2,3,4};
int[] b = a;
b[3] = 17;
~~~

Welchen Wert hat `a`?

-[ ] `3`
-[ ] `{1,2,3,4}`
-[ ] `{1,2,17,4}`
-[ ] `{1,2,3,17}`
-[ ] `17`
-[ ] `b`

**Nibble**: Eine Folge von vier Bits nennt man Nibble. Schreiben Sie eine Klasse `Nibble`, die ihre vier Bits in einer Variablen namens `bits` durch ein Array aus vier Ganzzahlen repräsentiert; jede dieser Ganzzahlen hat entweder den Wert 0 oder 1. Ein Hinweis: `bits[0]` repräsentiere das _Most Significant Bit_ (MSB), `bits[3]` das _Least Significant Bit_ (LSB).

1. Implementieren Sie die Konstruktoren und eine `toString`-Methode, so dass die folgenden Verwendungen möglich sind:

~~~ text
jshell> Nibble n = new Nibble(new int[]{1,0,0,1})
n ==> Nibble("1001")

jshell> n = new Nibble("1101")
n ==> Nibble("1101")

jshell> n = new Nibble(new Nibble("0011"))
n ==> Nibble("0011")
~~~

2. Realisieren Sie die binäre Addition und die binäre Invertierung. (Klären Sie zuvor, welcher Programmierstil vorliegt!)

~~~ text
jshell> n = new Nibble("0110")
n ==> Nibble("0110")

jshell> n.add(new Nibble("0011"))

jshell> n
n ==> Nibble("1001")

jshell> n.inv()

jshell> n
n ==> Nibble("0110")
~~~

3. Das Zweierkomplement (_two's complement_) ist definiert als Invertierung und Addition mit Eins. Setzen Sie die Methode um. (Die zweifache Anwendung des Zweierkomplements führt zum Ausgangswert zurück, siehe Beispiel.)

~~~ text
jshell> n
n ==> Nibble("0110")

jshell> n.twosComplement()

jshell> n
n ==> Nibble("1010")

jshell> n.twosComplement()

jshell> n
n ==> Nibble("0110")
~~~

4. Die binäre Subtraktion lässt sich zurückführen auf die Addition. Der übergebene Wert wird zuvor über das Zweierkomplement "negiert" und kann dann addiert werden.

~~~ text
jshell> n
n ==> Nibble("0100")

jshell> n.sub(new Nibble("0011"))

jshell> n
n ==> Nibble("0001")
~~~

5. Gegen Sie den über das Nibble kodierten dezimalen Zahlenwert einmal als natürliche Zahl, einmal als Ganzzahl zurück.

~~~ text
jshell> new Nibble("0101").toNatNum()
$54 ==> 5

jshell> new Nibble("0101").toIntNum()
$55 ==> 5

jshell> new Nibble("1101").toNatNum()
$56 ==> 13

jshell> new Nibble("1101").toIntNum()
$57 ==> -3
~~~

!!! 
    Ihre Hausaufgabe: Schreiben Sie den Code so um, dass die `Nibble`-Objekte immutabel sind.

<details>
    <summary>Lösung: Nibble</summary>
Ich verwende die `assert`-Anweisung einerseits um auszudrücken, dass der Code bestimmte Erwartungen hat, um funktionsfähig zu sein. Zum anderen verwende ich `assert`-Anweisungen am Ende zum Testen des Code. Normalerweise ignoriert Java `assert`-Anweisungen. Um sie zu aktivieren, müssen Sie die JShell starten mit `jshell -R-ea`; das `-ea` ist eine Compiler-Option und ist eine Abkürzung für _enable assertions_, "aktiviere die `assert`-Anweisungen".

~~~ java
class Nibble {
    int[] bits = {0, 0, 0, 0}; // MSB ... LSB
    Nibble(int[] bits) {
        assert bits != null && bits.length == this.bits.length;
        for(int i = 0; i < this.bits.length; i++) 
            this.bits[i] = bits[i] == 0 ? 0 : 1;
    }
    Nibble(String s) {
        assert s != null && s.length() >= this.bits.length;
        for(int i = 0; i < bits.length; i++)
            bits[i] = s.charAt(i) == '0' ? 0 : 1;
    }
    Nibble(Nibble n) {
        for(int i = 0; i < bits.length; i++) bits[i] = n.bits[i];
    }
    int add(Nibble n, int carry) {
        assert carry == 0 || carry == 1;
        int sum = 0;
        for(int i = bits.length - 1; i >= 0; i--) {
            sum = bits[i] + n.bits[i] + carry;
            bits[i] = sum % 2;
            carry = sum / 2;
        }
        return carry;
    }
    void add(Nibble n) {
        add(n, 0);
    }
    void inv() { // invert
        for(int i = 0; i < bits.length; i++)
            bits[i] = 1 - bits[i];
    }
    void twosComplement() {
        inv();
        add(new Nibble("0001"));
    }
    void sub(Nibble n) {
        Nibble temp = new Nibble(n);
        temp.twosComplement();
        add(temp);
    }
    int toNatNum() {
        int base = 1;
        int sum = 0;
        for(int i = bits.length - 1; i >= 0; i--) {
            sum += base * bits[i];
            base *= 2;
        }
        return sum;
    }
    int toIntNum() {
        /* Alternative:
        int nat = toNatNum();
        return -8 * (nat / 8) + nat % 8;
        */
        int nat = toNatNum();
        return nat <= 7 ? nat : -16 + nat;
    }
    public String toString() {
        String s = "Nibble(\"";
        for(int bit : bits) s += bit;
        return s + "\")"; 
    }
}

assert new Nibble("0000").toIntNum() == 0;
assert new Nibble("0001").toIntNum() == 1;
assert new Nibble("0010").toIntNum() == 2;
assert new Nibble("0011").toIntNum() == 3;
assert new Nibble("0100").toIntNum() == 4;
assert new Nibble("0101").toIntNum() == 5;
assert new Nibble("0110").toIntNum() == 6;
assert new Nibble("0111").toIntNum() == 7;
assert new Nibble("1000").toIntNum() == -8;
assert new Nibble("1001").toIntNum() == -7;
assert new Nibble("1010").toIntNum() == -6;
assert new Nibble("1011").toIntNum() == -5;
assert new Nibble("1100").toIntNum() == -4;
assert new Nibble("1101").toIntNum() == -3;
assert new Nibble("1110").toIntNum() == -2;
assert new Nibble("1111").toIntNum() == -1;
~~~
</details>

# VW6

!!! WARNING
    Zur Erinnerung: Der Dienstagstermin entfällt diese Woche.

!!! WARNING
    Leider muss auch der Termin am Mittwoch ausfallen.

Ich informiere Sie noch kurz über Moodle und Slack.

# VW7

**Identität und Gleichheit**: Gegeben sei die folgende Klasse namens `Point`:

~~~ java
class Point {
    double x, y;
    Point(double x, double y) {
        this.x = x;
        this.y = y;
    }
}
~~~

Erklären Sie anhand der Beispielklasse, was es bedeutet, wenn zwei Instanzen der Klasse `Point` identisch sind! Und was bedeutet es, wenn sie gleich sind?

**Trinkflasche**: Eine Flasche (_bottle_) kann ein bestimmtes Volumen haben. Eine Flasche kann man befüllen, man kann auch einen Teil ihres Inhalts oder den gesamten Inhalt ausschütten. Außerdem ist eine Flasche mit einem Deckel verschließbar. Ihre Aufgabe ist es, die Flasche, ihre Eigenschaften und das, was man mit ihr tun kann, in Form eines Java-Programms zu modellieren und abzubilden. 

<details>
    <summary>Lösung: Identität und Gleichheit</summary>
Es gibt in den Java den `instanceof`-Operator, um festzustellen, ob ein Objekt eine Instanz einer Klasse ist.

!!! Tip
    Der `instanceof`-Operator wird typischerweise in Implementierungen der `equals`-Methode benötigt. Wenn Sie außerhalb von `equals` den `instanceof`-Operator benötigen, dann haben Sie in 99,9% der Fälle ihren Code nicht objektorientiert organisiert, sondern versuchen, Objektorientierung nachzubilden. Der Witz an OO ist, dass Sie vor allem die Methoden mit einem Typ (einer Klasse oder einem Interface) verknüpfen, dass abhängig vom Typ die entsprechende Instanzvariable bzw. Instanzmethode ausgewählt wird. Wenn Sie aktiv den Typ testen, um daran das Verhalten des Code auszurichten, rüsten Sie manuell nach, was Ihnen die Objektorientierung "schenkt".

~~~ text
jshell> class K {}
|  created class K

jshell> K k = new K()
k ==> K@458c1321

jshell> k instanceof K
$54 ==> true

jshell> null instanceof K
$55 ==> false
~~~

Der Wert `null` ist keine Instanz irgendeiner Klasse.

Ganz viel von dem Denken in Objekten als Instanzen von Klassen lässt sich auf die [Mengenlehre](https://de.wikipedia.org/wiki/Mengenlehre) zurückführen -- jedenfalls ist das eine sehr gute Annäherung an die formale Betrachtung von Objekten und Klassen. Klassen entsprechen Mengen und Objekte den Elementen einer Menge. Ein Objekt ist immer ein Element in der Menge, die für die Klasse steht, von der das Objekt eine Instanz ist. 

[Reflexivität](https://de.wikipedia.org/wiki/Reflexive_Relation)
: Für alle Instanzen `obj` der Klasse `K` gilt: `obj.equals(obj) == true` (`obj != null`)


Wichtige Quellen zu `equals`:

* Kapitel 9.3.1 ("Objektgleichheit mit equals(…) und Identität") aus "Java ist auf eine Insel": http://openbook.rheinwerk-verlag.de/javainsel/09_001.html#u9.1.3
* Die Dokumentation zu `equals` der Klasse `Object`: https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)
* Die Dokumentation zu `hashCode` der Klasse `Object`: https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Object.html#hashCode()


</details>


<details>
    <summary>Lösung: Trinkflasche</summary>
Wenn Sie so eine Aufgabe lesen und ich von der Modellierung spreche, dann fordert Sie das heraus, Entscheidungen zu treffen darüber, in welcher Art und Weise die Flasche eine Funktion oder Aufgabe in welchem Art von Weltausschnitt für welchen Zweck erfüllt. Es ist alles andere als trivial, sich die folgenden Gedanken zu machen, um sich einer bestimmten Modellvorstellung von einer Flasche zu nähern: 

* Welche Funktion hat eine Trinkflasche? -- Sie dient der Aufbewahrung und dem Transport von Flüssigkeiten. Das ist nicht notwendigerweise die einzig mögliche Verwendungszweck einer Flasche. Man kann darin auch einen Zettel unterbringen und als Flaschenpost auf Reisen schicken. Oder man bewahrt Sand oder ein Gewürz darin auf. Sie kennen aber auch z.B. die Gasflasche. Die Aufgabe verengt die Perspektive auf eine Flasche eines eigentlich unklaren Typs und betrachtet sie für einen bestimmten Zweck und schreibt ihr eine klar umschriebene Verwendung zu. 
* Welche Funktion hat der Deckel einer Trinkflasche? -- Er sorgt dafür, dass Aufbewahrung und Transport verlustfrei geschehen können: Die Flüssigkeit kann weder verdunsten noch auflaufen. Wir gehen in der Aufgabe automatisch davon aus, dass ein Deckel immer passt und seine Funktion als Verschluss tadellos erfüllt.
* Was ist der Grund, bei einer Flasche ihr Volumen anzugeben? -- Das Volumen gibt das Fassungsvermögen der Flasche an. Die Volumenangabe dient oft auch als Abstraktion von der Form. Zwar haben wir alle eine Vorstellung davon, wie eine "Flasche" aussieht, doch ist uns in dieser Aufgabe weder die Form, noch das Material, noch ihre Farbe wichtig. Der Begriff der Reduktion ist hier also so gemeint, dass wir uns loslösen von materiellen Eigenschaften und die Flasche lediglich im Aspekt ihrer Funktion der Aufnahme einer Flüssigkeit betrachten. In Informatikmodellen und in Programmiercode vernichten wir oft sogar gänzlich unbewusst bestimmte Informationen über die Welt und arbeiten teils mit extrem vereinfachten Vorstellungsmodellen.
* Was kommt in die Flasche hinein? -- Was die Volumenangabe nicht "wegdenkt", ist die Art des Inhalts. Das gilt auch dann, wenn man sich nur auf Flüssigkeiten beschränkt: Geht es um Wasser, Cola, Öl, Farbe? Wenn man den Anteil des genutzten Flaschenvolumens mit einer Zahl abbildet, dann drückt sich darin aus, wie groß der Anteil der verbrauchten Kapazität der Flasche ist -- unabhängig vom konkreten Inhalt. Das ist wieder eine Reduktion, die bemerkenswert ist.

Diese Fragen zum Verständnis einer Flache sind das eine. Das andere ist der Kontext, in dem wir eine Flasche sehen: Welche Anteile der Umwelt interagieren wie mit der Flasche? Die Aufgabenstellung deutet es an: Es gibt die Handlung, die Flasche zu befüllen (_fill_, _pour in_), und die Handlung, etwas mit der Flasche auszugießen oder auszuschenken (_pour out_). Die Annahme in der Objektorientierung ist, dass diese Handlungen derart gekoppelt sind an eine Flasche, dass man die Flasche zum Kontext der Handlung macht (sie ist sowas wie ein Bezugspunkt der Handlung), d.h. `pourIn` und `pourOut` betrachtet man als Methoden der Klasse Flasche, also `Bottle`.
</details>







# Ablage und Verschiebebahnhof

**Firma**: Legen Sie eine Klasse namens `Person` an; eine Person hat ein Alter (`age`) und einen Namen (`name`). Legen Sie eine Klasse namens `Firm` an, die einen Namen `name` hat und ein Array vom Typ `Person`, das die Angestellten (`employees`) repräsentiert. (1) Legen Sie Instanzen mit Beispielwerten an. (2) Zeichnen Sie das Objektbild dazu.

# Gruppenarbeit und Delegiertentreffen

Es gibt viele Arten des Lernens: Man kann selber tüfteln, bis man die Lösung hat. Dann hätte man gerne vielleicht einen Lösungsvorschlag zum Vergleich. (Ich scheue das Wort "Musterlösung", weil es in der Programmierung oft mehrere Möglichkeiten der Lösung gibt, was auch abhängt von den Programmierkonstrukten, die sie beherrschen.) Manchmal ist es auch sinnvoll, frühzeitig in die Lösung zu schauen, damit man sich abgucken kann, wie das Programmieren funktioniert. Es ist nicht sinnvoll, wenn man über Stunden auf dem Schlauch steht. Das "Spicken" in die Lösung kann eine große Hilfe und eine sehr effektive Lernstrategie sein. Mit jeder weiteren Aufgaben kommt man so eigenständig voran und probiert es alleine.

Eines möchte ich besonders betonen: Die Lerneffekte können enorm sein, wenn Sie in der Gruppe arbeiten. Sie diskutieren, probieren, geben sich gegenseitig Hilfestellung und Anregung und können Lösungen oder Lösungsideen vergleichen. Wenn Sie es schaffen, eine gute Programmiergruppe zu sein, dann ist das gleichzeitig eine hervorragende Lerngruppe. In der Praxis ist Entwicklungsarbeit längst zu einem "Teamsport" geworden -- dafür sind die Aufgaben und Herausforderungen, vor denen die Entwickler:innen stehen, einfach zu groß als dass man alleine zum Ziel käme.

## Vom Sinn der Gruppenarbeit

Sie haben eine Vielzahl an Java-Aufgaben zur Bearbeitung vor sich. Und in vielen Fällen wird Ihnen sogar die Musterlösung mitgeliefert. Wozu in aller Welt bedarf es da der Gruppenarbeit?

Eine gute Frage -- und eine wichtige Frage, weil sich dahinter eine grundlegende Annahme verbirgt: Wenn ich alle Informationen habe, dann kann ich alleine lernen. Stimmt, können Sie! Wenn man Ihnen alles zur Verfügung stellt, dann sind die Voraussetzungen gegeben, alles alleine zu bearbeiten und mich sich selbst zu klären.

Mit den Aufgaben und den Lösungen sind also gute Voraussetzungen zum Lernen geschaffen. Aber damit ist das Problem des Lernens nicht gelöst. Lernen heißt, sich Zeit freizuschaufeln, sich hinzusetzen, sich zu konzentrieren, Ablenkungen und Störungen auszuschalten -- und dann lernt man immer noch nicht, sondern hat für sich nur die Rahmenbedingungen dafür geschaffen, dass das Lernen stattfinden kann. Das Lernen selbst ist ein Tun und ein Machen: Man muss die Aufgabe lesen, sie verstehen, was sie von einem will, in der Vorlesung/Übung kennengelernte Konzepte versuchen anzuwenden, eine Lösung ausprobieren, sie in der JShell eintippen, die Frustration ertragen, wenn es nicht gleich klappt, sich neu mit der Aufgabe befassen, neue Wege einschlagen, experimentieren. Es ist zu erwarten, dass Ihnen diese Denkarbeit arg zu schaffen macht. Das Programmieren ist nichts, was dem menschlichen Gehirn als Fähigkeit angeboren wurde. In Ihnen wird sich rasch eine innere Stimme breit machen, die den Sinn und Zweck der ganzen Aktion hinterfragt, Ihre Motivationslage wird brüchig -- und das Handy als Ablenkung ist nicht fern.

Ahnen Sie, dass das Lernen wenig mit damit zu tun hat, ob Ihnen alle Informationen zur Verfügung stehen? Sie müssen sich zwingen, sich disziplinieren, Widerstände aushalten, eine Frustrationstoleranz entwickeln. Und wenn Sie wenig an Selbstwirksamkeitserfahrungen haben, dann wird es nicht leichter. Das hat nicht viel mit Spaß am Lernen zu tun.

Das Ganze kann sich sehr leicht auflösen, wenn Menschen ihrer sozialen Ader folgen und sich für Klatsch, Tratsch aber auch zur Bewältigung von Problemen, Aufgaben und Herausforderungen treffen. Wenn Sie sich einigen Regeln des Zusammenseins unterwerfen (z.B. eine feste Gruppenzeit zum Lernen an einem bestimmten Ort), dann spielen all die Punkte wie Selbstdisziplinierung, Konzentration usw. keine Rolle. Wer miteinander an einer harten Aufgabe brütet, ist konzentriert. Schwierigkeiten lassen sich lösen, indem man Ideen austauscht und sich hilft. Das Smartphone lässt sich vergessen, Frustrationen lassen sich ertragen, Probleme finden viel eher Lösungen.

Es ist an Ihnen, aus Ihrer Zufallszuweisung zu einer Gruppe eine fruchtbare Zweckgemeinschaft entstehen zu lassen. Niemand verlangt von Ihnen, dass Sie Freunde werden. Aber auch eine Zweckgemeinschaft wächst nur zusammen, wenn sie sich trifft, wenn man sich begegnet und einander im Interesse eines gemeinsamen Anliegens offen und aufgeschlossen zuwendet. Wenn Sie eine Gruppe werden, eröffnet sich auch die Chance, dass Sie sich online, z.B. über Slack, helfen können. Es ist was schönes, die Lernpartner in digitaler Nähe zu wissen!

Wir versuchen durch verschiedenste Interventionen (sie könnte es auch "Maßnahmen" nennen), Sie als Gruppe zusammenzubringen. Wir erwarten, dass Sie dabei mitmachen! Ein Punkt ist zum Beispiel das regelrechte Überschütten mit Aufgaben. In der Gruppe können Sie sich Strategien überlegen, wie man damit umgeht. Was man durch Arbeitsteilung und gegenseitiges Erklären erreichen kann, reicht weit über das hinaus, wenn man versucht, sich mühsam alles selbst zu erschließen. Sie müssen die Sachen zwar alle selber können, aber das heißt nicht, dass Sie alles alleine erarbeiten müssen.

## Was erwartet Sie als Delegierte:r beim Delegiertentreff?

Was wird eigentlich beim Delegiertentreff gemacht? Wir haben am Dienstag Punkte an der Tafel gesammelt, die skizzieren, was alles möglich und denkbar ist:

* Wir können mit Ihnen Probleme und Lösungswege besprechen
* Gibt es Probleme in der Gruppe? Brauchen Sie unsere Hilfe und/oder Moderation?
* Wir können gegenseitig unser Wissen testen
* Sie können Fragen stellen
* Sie sind Botschafter ihrer Gruppe: Was haben Sie uns interessanter mitzuteilen? Sollen Sie im Auftrag eines Gruppenmitglieds etwas erfragen oder erbitten?
* Lassen Sie uns gemachte Erfahrungen teilen und Feedback z.B. zu Aufgaben geben
* Gibt es Sachen oder Aufgaben aus der Vorlesung/Übung, bei der es Probleme gab. Für mich sind solche Rückmeldungen sehr wichtig, die Tutoren melden mir das zurück und ich kann in künftigen Veranstaltungen darauf eingehen.
* Sie können Kontakte knüpfen
* Sie überlegen sich mit uns Aufgabenvarianten
* Braucht jemand individuelle Förderung? Wir versuchen Hilfe anzubieten, die dann im Rahmen der Tutoren-Sprechstunde geleistet werden kann

## Was ist Vorbereitung?

Als Delegierte:r sollen Sie vorbereitet beim Delegiertentreffen erscheinen. Was heißt es, _vorbereitet_ zu sein?

In Wikipedia heißt es unter dem Eintrag "[Vorbereitung (Kochen)]("https://de.wikipedia.org/wiki/Vorbereitung_(Kochen)")" im Abschnitt "Bedeutung": "Die Vorbereitung von Lebensmitteln ist die Voraussetzung für das Kochen und Backen." (Abruf am 17.10.2019) Wenn wir das auf die Vorbereitung zum Delegiertentreff übertragen: Ihre Vorbereitung ist die Voraussetzung für einen fruchttragenden Gesprächsaustausch und einen Lernfortschritt, den Sie und Ihr Team machen können.

Vorbereitet zu sein heißt:

* Sie haben sich mit den Aufgaben beschäftigt. Das heißt nicht, dass Sie alle Aufgaben selber bearbeitet und gelöst haben -- dafür arbeiten Sie ja im Team und haben sich die Arbeit möglicherweise aufgeteilt. Aber Sie kennen die Aufgabenstellungen, niemand müsste sie Ihnen noch einmal erläutern.
* Sie kennen den Status Ihres Teams. Sie wissen, wer an welcher Aufgabe gearbeitet hat, wer was gelöst hat, welche Probleme aufgetaucht sind. Wo konnte die Gruppe helfen, wo sind offene Fragen. Holen Sie die Infos von Ihren Teammitgliedern ein.
* Sie haben sich ein Bild von Ihrer Gruppe gemacht: Funktioniert unsere Zusammenarbeit? Was läuft gut? Was könnte besser laufen? Ist wer aus unserem Team abgehängt oder prescht jemand zu sehr vor und überfordert mit ihrem oder seinem Verhalten die Gruppe?
* Welche Fragen soll ich für einzelne Teammitglieder klären? Das können neben Fragen zu Aufgaben auch Fragen zu Vorlesung oder Übung sein.
* Ich habe das notwendige Material dabei: Laptop, Stift, Papier, Unterlagen (eventuell z.B. das Kofler-Buch)

## Aufgabenrhythmus

Wenn Sie im Git-Repository zu einem Aufgabenpaket den Eintrag "VW3" sehen (als Beispiel), dann ist damit Folgendes gemeint: Dieses Aufgabenpaket wird am Freitag in der dritten Vorlesungswoche das neue Arbeitspaket ihrer Gruppe. Die Delegierte bzw. der Delegierte bringt die Arbeitsergebnisse zu diesem Arbeitspaket am Freitag in der Folgewoche (im Beispiel also in VW4) mit zum Delegiertentreffen.

# Spaß mit Processing

Einige von Ihnen möchten sich schon mit Processing befassen. Gerne, tun Sie das -- vernachlässigen Sie aber bitte nicht, sich auch mit den regulären Inhalten unserer Veranstaltung zu befassen. Die Projektwoche ist für die Arbeit mit Processing vorgesehen.

Processing ([](https://processing.org)) ist eine Java-Programmbibliothek vor allem für die graphische Programmierung und eine Entwicklungsumgebung, um solche graphisch-orientierten Programme zu erstellen. Man programmiert mit Processing in Java, allerdings hat die Entwicklungsumgebung geringfügige Änderungen an der Syntax von Java vorgenommen, so dass sich die Programmierung im ersten Moment gar nicht nach Java anfühlt. Processing ist so beliebt geworden, dass es auch Implementierungen für die Programmiersprachen Python ([](https://py.processing.org/)) und JavaScript ([](https://p5js.org)) gibt.

!!! WARNING
    Wir arbeiten in diesem Kurs nicht mit der Entwicklungsumgebung, die Processing selber mitliefert. Grund ist, dass dort die Sprachversion von Java auf dem Stand von Java 8 stehen geblieben ist. Wir wollen aber modern bleiben! Zum Glück kann man die Processing-Bibliothek ganz leicht in Java 13 importieren, um mit ihr zu arbeiten.

## Voraussetzungen

Wenn wir auf die Programmierumgebung von Processing verzichten, dann brauchen wir die Java-Programmbibliothek. Die Kernbibliothek zu Processing (_Processing Core_) finden Sie in den Maven-Verzeichnissen:

https://mvnrepository.com/artifact/org.processing/core

Wählen Sie die jüngste Version aus (im Moment ist es Version 3.3.7) und laden Sie die `jar`-Datei (`core-3.3.7.jar`) herunter in das Verzeichnis, in dem Sie Ihre Programme entwickeln wollen, die mit der Kern-Bibliothek von Processing arbeiten sollen.

## Ein Beispielprogramm

Erstellen Sie mit einem Editor eine Datei namens `GrabBall.java` mit folgendem Inhalt:

~~~ java
// Original source code: https://gist.github.com/denkspuren/86e2132b6563d609902e
// Minor adaptations were required for a Java 13 environment.  

import processing.core.PApplet;
import processing.core.PGraphics;

public class MySketch extends PApplet {
    public static void main(String[] args) {
        String[] appArgs = {"Grab Ball"};
		MySketch mySketch = new MySketch();
		PApplet.runSketch(appArgs, mySketch);
    }

    int THMGreen = color(128, 186, 36);
    int THMGrey  = color(74, 92, 102);
    int THMRed   = color(184, 0, 64);

    float x, y;
    int time;
    int count = 0;

    public void settings() {
        size(400, 300);
      }

    public void setup() {
        background(THMGreen);
        noStroke();
        paintNewEllipse(THMGrey);
    }

    void paintNewEllipse(int color) {
        x = random(0+20, 400-20);
        y = random(0+20, 300-20);
        fill(color);
        ellipse(x, y, 40, 40);
    }

    public void draw() {
        if (count == 0) {
            time = millis();
        } else {
            fill(THMGreen);
            rect(0, 0, 60, 20);
            fill(THMGrey);
            text((20000f+time-millis())/1000f, 10, 15);
        }
        if (get(mouseX, mouseY) == THMGrey) {
            fill(THMRed);
            ellipse(x, y, 40, 40);
            paintNewEllipse(THMGrey);
            count++;
        }
    }
}
~~~

Das ist übrigens die Anpassung eines kleinen Beispielprogramms, das ich mal geschrieben habe in der Entwicklungsumgebung von Processing, [hier](https://gist.github.com/denkspuren/86e2132b6563d609902e) ist der originale Code dazu. Da die Entwicklungsumgebung (wie gesagt) ein bissel von Java abweicht, läuft der Code nicht direkt mit Java 12 oder Java 13.

Starten Sie die Anwendung! Denken Sie daran, `core.jar` und `GrabBall.java` müssen dafür im selben Verzeichnis abgelegt sein.

~~~ text
> java -cp core.jar GrabBall.java
~~~

Voila! "Berühren" Sie mit der Maus den grauen Kreis und er wird seine Farbe wechseln. Ein neuer Kreis erscheint. Der Timer ist nur zu Demozwecken eingebaut, er ist ohne Funktion.

![Ein einfaches Demospiel mit der Processing-Bibliothek](pics/GrabBall.png)`

Sie können die Anwendung auch mit der JShell laden und starten.

~~~ text
> jshell --class-path core.jar GrabBall.java
|  Welcome to JShell -- Version 12.0.2
|  For an introduction type: /help intro

jshell> MySketch.main(new String[]{})
~~~

## Von Processing zu reinem Java

Um Processing-Programme in reine Java-Programme umzuwandeln, muss man ein paar Details wissen. Wird zum Beispiel eine Variable mit dem Typ `color` ausgezeichnet, dann ist das eigentlich der primitive `int`-Typ; `color` ist ein Pseudotyp in der Entwicklungsumgebung von Processing, man wollte Anfänger*innen das Programmieren ein wenig verständlicher machen.

Die in Processing zur Verfügung stehenden Sprachkonstrukte und "Befehle" (es sind eigentlich Java-Methoden), finden Sie unter

https://processing.org/reference/

Diese Referenz ist Ihr wichtigstes Hilfsmittel bei der Erstellung von Processing-Programmen in "reinem" Java. Aus diesem Grund müssen Sie manchmal wissen, in welchen Paket sich eine Methode aus der Referenz befindet, um sie nutzen zu können. Da hilft Ihnen die Code-Dokumentation zu `core.jar`:

http://processing.github.io/processing-javadocs/core/

Über den "Index" sind rasch die Methoden und darüber die Pakete gefunden. Zum Beispiel ist die `text`-Methode eine Methode der Klasse `processing.core.PGraphics`. Deshalb finden Sie oben auch die entsprechende `import`-Anweisung, um die Methode aus der Kernbibliothek von Processing unkompliziert nutzen zu können.

Das klingt alles etwas schwierig? Keine Sorge, das ist es nicht. Noch sind wir ja nicht soweit, wir greifen hier vor.
 

<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js"></script><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
